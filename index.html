<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title>Recommend Page</title>

  <style>
    /* ▼ アプリ内ブラウザ向けのベース設定 */
    html {
      height: 100dvh; /* 動的な高さに対応 */
      margin: 0;
      background: #1a103c;
      overscroll-behavior: none; /* バウンススクロール禁止 */
    }
    body {
      height: 100%;
      margin: 0;
      background: #1a103c;
      /* アプリっぽくするための設定 */
      -webkit-user-select: none; user-select: none; /* 文字選択禁止 */
      -webkit-touch-callout: none; /* 長押しメニュー禁止 */
      -webkit-tap-highlight-color: transparent; /* タップ時のグレー背景削除 */
      overflow: hidden; /* スクロールは内部で行う */
    }
  </style>
</head>

<body>

<div id="valentine-scope">
  <style>
    #valentine-scope {
      /* ▼ アプリの配色から抽出したカラーパレット */
      --v-bg: #1a103c;         /* メイン背景 */
      --v-card-bg: #261b4a;    /* カード背景（少し明るく） */
      --v-text: #ffffff;       /* 白文字 */
      --v-muted: #bca4d6;      /* 薄紫の補足文字 */
      --v-accent1: #7c4dff;    /* アクセント（ボタンなど） */
      --v-accent2: #a855f7;    /* グラデーション用 */
      --v-border: rgba(255, 255, 255, 0.2); /* 枠線 */

      font-family: ui-sans-serif, system-ui, -apple-system, sans-serif;
      color: var(--v-text);

      background: var(--v-bg);

      position: relative;
      width: 100%;
      height: 100%;
      margin: 0;
      overflow: hidden;
      isolation: isolate;
      display: flex;
      flex-direction: column;

      /* ▼ iPhoneのノッチ・ホームバー対策 */
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);

      opacity: 0;
      transition: opacity .18s ease;
    }

    #valentine-scope * {
      box-sizing: border-box;
      /* タップ反応速度の向上 */
      touch-action: manipulation;
    }

    #valentine-scope .scroll-area {
      flex: 1;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch; /* 慣性スクロール */
      padding: 20px 16px 80px;
    }

    #valentine-scope .topbar {
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:12px;
      margin-bottom: 24px;
      padding-bottom: 16px;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }

    #valentine-scope .title {
      font-size: 18px;
      font-weight: 700;
      margin:0;
      line-height:1.3;
      color: #fff;
    }

    #valentine-scope .subtitle {
      color: var(--v-muted);
      font-size: 12px;
      margin-top: 4px;
      white-space: pre-line;
    }

    #valentine-scope .chip {
      border:1px solid var(--v-border);
      background: rgba(255,255,255,0.05);
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 11px;
      color: var(--v-muted);
      flex-shrink: 0;
      display: inline-block;
    }

    #valentine-scope .stepRow {
      display:flex;
      align-items:center;
      gap: 10px;
      margin-bottom: 16px;
    }

    #valentine-scope .bar {
      height: 4px;
      border-radius: 999px;
      background: rgba(255,255,255,0.15);
      flex: 1;
      overflow: hidden;
    }
    #valentine-scope .bar > div {
      height:100%;
      background: #fff;
      transition: width .4s ease;
    }

    #valentine-scope .card {
      border: none;
      background: transparent; 
      padding: 0; 
      animation: val-slideUp .4s ease;
    }

    #valentine-scope .q {
      font-size: 18px;
      font-weight: 700;
      margin-bottom: 24px;
      line-height: 1.5;
      color: #fff;
    }

    #valentine-scope .choiceBtn {
      display:flex;
      align-items:center;
      gap:12px;
      border: 1px solid var(--v-accent1);
      background: rgba(124, 77, 255, 0.1);
      color: var(--v-text);
      padding: 16px 20px;
      border-radius: 999px;
      width: 100%;
      cursor:pointer;
      text-align:left;
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 12px;
      transition: .2s;
    }
    /* スマホ用にactiveを追加（タップした瞬間） */
    #valentine-scope .choiceBtn:active {
      background: rgba(124, 77, 255, 0.3);
      transform: scale(0.98); /* 少し沈む感触 */
    }

    #valentine-scope .resultTitle {
      font-size: 20px;
      font-weight: 800;
      margin-bottom: 12px;
      color: #fff;
    }
    #valentine-scope .resultBody {
      font-size: 14px;
      line-height: 1.8;
      margin-bottom: 20px;
      white-space: pre-line;
      color: rgba(255,255,255,0.9);
    }

    #valentine-scope .recCard {
      border: 1px solid rgba(255,255,255,0.1);
      background: var(--v-card-bg);
      border-radius: 12px;
      padding: 12px;
      margin-bottom: 12px;
      display: flex;
      gap: 12px;
      align-items: center;
    }

    #valentine-scope .avatar {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      background: rgba(255,255,255,0.05);
      object-fit: cover;
      object-position: center;
      flex-shrink: 0;
      border: 1px solid rgba(255,255,255,0.1);
    }

    #valentine-scope .ctaBtn {
      display: inline-block;
      text-decoration: none;
      background: var(--v-accent1);
      color: white;
      padding: 8px 16px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: bold;
      flex-shrink: 0;
      white-space: nowrap;
    }
    #valentine-scope .ctaBtn:active {
      transform: scale(0.95);
    }

    #valentine-scope .bottomBar {
      position: absolute;
      left: 0; right: 0; bottom: 0;
      padding: 16px;
      /* iPhoneの下線(Home Indicator)対応 */
      padding-bottom: calc(16px + env(safe-area-inset-bottom));
      background: #150c30;
      border-top: 1px solid rgba(255,255,255,0.1);
      display: flex;
      gap: 12px;
      z-index: 10;
    }
    #valentine-scope .navBtn {
      flex: 1;
      border-radius: 8px;
      padding: 12px;
      border: none;
      background: rgba(255,255,255,0.1);
      color: var(--v-text);
      cursor:pointer;
      font-weight: 600;
      font-size: 13px;
    }
    #valentine-scope .navBtn:disabled { opacity: 0.3; }
    #valentine-scope .navBtn:active { background: rgba(255,255,255,0.2); }

    #valentine-scope .loadingCard{
      text-align: center;
      padding-top: 40px;
    }
    #valentine-scope .spinner{
      width: 24px; height: 24px;
      border-radius: 50%;
      border: 3px solid rgba(255,255,255,.2);
      border-top-color: #fff;
      display:inline-block;
      animation: spin .8s linear infinite;
      vertical-align: middle;
      margin-right: 8px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    @keyframes val-slideUp {
      from { opacity:0; transform:translateY(10px); }
      to { opacity:1; transform:translateY(0); }
    }
  </style>

  <div class="scroll-area">
    <div class="topbar">
      <div>
        <h1 class="title" id="ui-title">Recommend</h1>
        <div class="subtitle" id="ui-subtitle">読み込み中…</div>
      </div>
      <div class="chip" id="ui-chip"></div>
    </div>

    <div id="val-app"></div>
  </div>

  <div class="bottomBar">
    <button class="navBtn" id="val-backBtn" disabled="">戻る</button>
    <button class="navBtn" id="val-resetBtn">最初から</button>
  </div>

  <script>
    (function(){
      // ✅ 設問（public: 2PACX）
      const QUESTIONS_CSV_URL =
        "https://docs.google.com/spreadsheets/d/e/2PACX-1vRliKpYwepLa0Z1DzzqJtDtobsdZU1uthkjiVMmIF2zTplootZrK3hpxhsyeu7GEjI5e9Zxi2UdSpye/pub?gid=1750400212&single=true&output=csv";

      // ✅ 占い師（public: 2PACX）
      const RECS_CSV_URL =
        "https://docs.google.com/spreadsheets/d/e/2PACX-1vRliKpYwepLa0Z1DzzqJtDtobsdZU1uthkjiVMmIF2zTplootZrK3hpxhsyeu7GEjI5e9Zxi2UdSpye/pub?gid=0&single=true&output=csv";

      // ✅ results / settings
      const RESULTS_CSV_URL =
        "https://docs.google.com/spreadsheets/d/1-iNODBXpVHuF8500kBHvuJJG7XrR_pBGt-8FmClDB5o/gviz/tq?tqx=out:csv&gid=257661142";

      const SETTINGS_CSV_URL =
        "https://docs.google.com/spreadsheets/d/1-iNODBXpVHuF8500kBHvuJJG7XrR_pBGt-8FmClDB5o/gviz/tq?tqx=out:csv&gid=1350915999";


      let questions = [];
      let recs = { A: [], B: [], C: [] };
      let results = { A:{}, B:{}, C:{} };
      let ui = {
        title: "Recommend",
        subtitle: "読み込み中…",
        chip: "",
        recsHeading: "おすすめ",
        loadingRecs: "（占い師リストを読み込み中、または未設定です）",
        noQuestions: "設問がありません"
      };

      let state = { step: 0, score: { A:0, B:0, C:0 }, answers: [] };

      const scope = document.getElementById("valentine-scope");
      const app = document.getElementById("val-app");
      const backBtn = document.getElementById("val-backBtn");
      const resetBtn = document.getElementById("val-resetBtn");

      const uiTitle = document.getElementById("ui-title");
      const uiSubtitle = document.getElementById("ui-subtitle");
      const uiChip = document.getElementById("ui-chip");

      let loaded = { settings:false, results:false, questions:false, recs:false };
      let booted = false;

      function showLoading(){
        app.innerHTML = `
          <div class="loadingCard">
            <div style="font-size:12px;color:var(--v-muted);">
              <span class="spinner"></span>
              Now Loading...
            </div>
          </div>
        `;
      }

      function applyUI(){
        uiTitle.textContent = ui.title || "";
        uiSubtitle.textContent = (ui.subtitle || "").replace(/\\n/g, "\n");

        const chipText = (ui.chip || "").trim();
        uiChip.textContent = chipText;
        uiChip.style.display = chipText ? "inline-block" : "none";
      }

      function finishIfReady(){
        if(booted) return;
        if(loaded.settings && loaded.results && loaded.questions){
          booted = true;
          applyUI();
          render();
          scope.style.opacity = "1";
        }
      }

      function parseCSV(text){
        const rows = [];
        let row = [], cell = "", inQuotes = false;

        for(let i=0;i<text.length;i++){
          const c = text[i];
          const next = text[i+1];

          if(c === '"'){
            if(inQuotes && next === '"'){ cell += '"'; i++; }
            else { inQuotes = !inQuotes; }
          } else if(c === ',' && !inQuotes){
            row.push(cell); cell = "";
          } else if((c === '\n' || c === '\r') && !inQuotes){
            if(c === '\r' && next === '\n') i++;
            row.push(cell);
            if(row.length > 1 || (row[0] ?? "") !== "") rows.push(row);
            row = []; cell = "";
          } else {
            cell += c;
          }
        }
        row.push(cell);
        if(row.length > 1 || (row[0] ?? "") !== "") rows.push(row);

        const headers = (rows.shift() || []).map(h => (h || "").trim());
        return rows.map(r => {
          const obj = {};
          headers.forEach((h, idx) => obj[h] = (r[idx] ?? "").trim());
          return obj;
        });
      }

      function parseScore(type, pts){
        const t = (type || "").toUpperCase();
        const p = Number(pts || 0);
        if(!t || isNaN(p)) return {};
        return { [t]: p };
      }

      async function loadQuestionsFromSheet(){
        try{
          const res = await fetch(QUESTIONS_CSV_URL + "&ts=" + Date.now());
          const csv = await res.text();
          const rows = parseCSV(csv);

          const built = rows
            .map(r => {
              const qtext = r.qtext || "";
              if(!qtext) return null;

              const choices = [];
              if(r.choice1) choices.push({ l: r.choice1, s: parseScore(r.type1, r.pts1) });
              if(r.choice2) choices.push({ l: r.choice2, s: parseScore(r.type2, r.pts2) });
              if(r.choice3) choices.push({ l: r.choice3, s: parseScore(r.type3, r.pts3) });

              if(choices.length < 2) return null;

              return { qid: Number(r.qid || 999), text: qtext, choices };
            })
            .filter(Boolean)
            .sort((a,b) => a.qid - b.qid)
            .map(x => ({ text: x.text, choices: x.choices }));

          questions = built;

          state.step = 0;
          state.score = {A:0,B:0,C:0};
          state.answers = [];

          loaded.questions = true;
          finishIfReady();
        } catch(e){
          console.log("failed to load questions:", e);
        }
      }

      async function loadRecsFromSheet(){
        try{
          const res = await fetch(RECS_CSV_URL + "&ts=" + Date.now());
          const csv = await res.text();
          const rows = parseCSV(csv);

          const grouped = { A: [], B: [], C: [] };

          rows.forEach(r => {
            const type = (r.type || "").toUpperCase();
            if(!grouped[type]) return;

            grouped[type].push({
              n: r.name || "",
              s: r.badge || "",
              t: r.text || "",
              u: r.url || "",
              i: r.img || "",
              order: Number(r.order || 999)
            });
          });

          Object.keys(grouped).forEach(k => {
            grouped[k].sort((a,b) => a.order - b.order);
            grouped[k] = grouped[k].map(({order, ...rest}) => rest);
          });

          recs = grouped;

          loaded.recs = true;
          if(booted) render();
        } catch(e){
          console.log("failed to load recs:", e);
        }
      }

      async function loadResultsFromSheet(){
        try{
          const res = await fetch(RESULTS_CSV_URL + "&ts=" + Date.now());
          const csv = await res.text();
          const rows = parseCSV(csv);

          const map = {};
          rows.forEach(r => {
            const t = (r.type || "").toUpperCase();
            if(!t) return;
            map[t] = {
              title: r.title || "",
              body: (r.body || "").replace(/\\n/g, "\n"),
              tip: (r.tip || "").replace(/\\n/g, "\n")
            };
          });

          if(map.A || map.B || map.C){
            results = {
              A: map.A || {title:"",body:"",tip:""},
              B: map.B || {title:"",body:"",tip:""},
              C: map.C || {title:"",body:"",tip:""}
            };
          }

          loaded.results = true;
          finishIfReady();
        } catch(e){
          console.log("failed to load results:", e);
        }
      }

      async function loadSettingsFromSheet(){
        try{
          const res = await fetch(SETTINGS_CSV_URL + "&ts=" + Date.now());
          const csv = await res.text();
          const rows = parseCSV(csv);

          const map = {};
          rows.forEach(r => {
            const key = (r.key || "").trim();
            const value = (r.value || "");
            if(key) map[key] = value;
          });

          ui = { ...ui, ...map };

          loaded.settings = true;
          finishIfReady();
        } catch(e){
          console.log("failed to load settings:", e);
        }
      }

      function render(){
        backBtn.disabled = (state.step === 0);

        if(!questions || !questions.length){
          app.innerHTML = `
            <div class="card">
              <div class="q">${ui.noQuestions}</div>
              <div style="font-size:12px;color:var(--v-muted);">GSSのquestionsシートを確認してね。</div>
            </div>`;
          return;
        }

        if(state.step < questions.length){
          const q = questions[state.step];
          const pct = Math.round((state.step / questions.length) * 100);

          app.innerHTML = `
            <div class="card">
              <div class="stepRow">
                <div style="font-size:12px;color:var(--v-muted);">Q.${state.step+1}</div>
                <div class="bar"><div style="width:${pct}%"></div></div>
              </div>
              <div class="q">${q.text}</div>
              ${q.choices.map((c,i)=>`<button class="choiceBtn" data-idx="${i}">${c.l}</button>`).join('')}
            </div>`;

          app.querySelectorAll('.choiceBtn').forEach(b => b.onclick = () => choose(b.dataset.idx));
        } else {
          const win = Object.entries(state.score).sort((a,b)=>b[1]-a[1])[0][0];
          const r = results[win] || { title:"", body:"", tip:"" };
          const list = (recs[win] && recs[win].length) ? recs[win] : [];

          app.innerHTML = `
            <div class="card">
              <div class="resultTitle">${r.title || ""}</div>
              <div class="resultBody">${r.body || ""}</div>
              <div style="background:rgba(255,255,255,0.05);padding:15px;border-radius:12px;font-size:13px;margin-bottom:20px;white-space:pre-line;border:1px solid rgba(255,255,255,0.1);color:var(--v-muted);">${r.tip || ""}</div>
              <div style="font-size:14px;font-weight:bold;margin-bottom:12px;color:var(--v-text);">${ui.recsHeading || "おすすめ"}</div>

              ${list.length ? list.map(x=>`
                <div class="recCard">
                  <img class="avatar" src="${x.i}">
                  <div style="flex:1; min-width:0;">
                    <div style="font-weight:bold;font-size:14px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${x.n}</div>

                    <div style="
                      display:inline-block;
                      font-size:11px;
                      padding:2px 8px;
                      border-radius:999px;
                      color: rgba(255,255,255,0.9);
                      background: rgba(255,255,255,0.1);
                      margin-top: 4px;
                      margin-bottom: 4px;
                    ">
                      ${x.s}
                    </div>

                    <div style="font-size:11px;opacity:0.7;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden;">${x.t}</div>
                  </div>
                  <a href="${x.u}" class="ctaBtn">見る</a>
                </div>
              `).join('') : `
                <div style="font-size:12px;color:var(--v-muted);opacity:.95;">
                  ${ui.loadingRecs || "（読み込み中）"}
                </div>
              `}
            </div>`;
        }
      }

      function choose(idx){
        const sc = questions[state.step].choices[idx].s || {};
        Object.keys(sc).forEach(k => state.score[k] = (state.score[k] || 0) + sc[k]);

        state.answers[state.step] = { idx: Number(idx), sc };

        state.step++;
        render();
        document.querySelector('.scroll-area').scrollTo(0,0);
      }

      backBtn.onclick = () => {
        if(state.step > 0){
          state.step--;

          const prev = state.answers[state.step];
          if(prev && prev.sc){
            Object.keys(prev.sc).forEach(k => state.score[k] = (state.score[k] || 0) - prev.sc[k]);
          }

          state.answers[state.step] = undefined;

          render();
          document.querySelector('.scroll-area').scrollTo(0,0);
        }
      };

      resetBtn.onclick = () => {
        state.step = 0;
        state.score = {A:0,B:0,C:0};
        state.answers = [];
        render();
        document.querySelector('.scroll-area').scrollTo(0,0);
      };

      // 初期：ローディング
      showLoading();

      // 読み込み開始
      loadQuestionsFromSheet();
      loadRecsFromSheet();
      loadResultsFromSheet();
      loadSettingsFromSheet();
    })();
  </script>
</div>

</body>
</html>
